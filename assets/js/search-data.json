{
  
    
        "post0": {
            "title": "Linear Transformation",
            "content": "import numpy as np import matplotlib.pyplot as plt . x = np.arange(-10, 10, 1) y = np.arange(-10, 10, 1) xx, yy = np.meshgrid(x, y) . plt.scatter(xx, yy, s=30, c=xx+yy) # [...] Add axis, x and y witht the same scale . &lt;matplotlib.collections.PathCollection at 0x1227627f0&gt; . T = np.array([ [-1, 0], [0, -1] ]) . xy = np.vstack([xx.flatten(), yy.flatten()]) xy.shape . (2, 400) . trans = T @ xy trans.shape . (2, 400) . xx_transformed = trans[0].reshape(xx.shape) yy_transformed = trans[1].reshape(yy.shape) . f, axes = plt.subplots(1, 2, figsize=(6, 3)) axes[0].scatter(xx, yy, s=10, c=xx+yy) axes[1].scatter(xx_transformed, yy_transformed, s=10, c=xx+yy) # [...] Add axis, x and y witht the same scale . &lt;matplotlib.collections.PathCollection at 0x1228cc4f0&gt; . T = np.array([ [1.3, -2.4], [0.1, 2] ]) trans = T @ xy xx_transformed = trans[0].reshape(xx.shape) yy_transformed = trans[1].reshape(yy.shape) f, axes = plt.subplots(1, 2, figsize=(6, 3)) axes[0].scatter(xx, yy, s=10, c=xx+yy) axes[1].scatter(xx_transformed, yy_transformed, s=10, c=xx+yy) # [...] Add axis, x and y witht the same scale . &lt;matplotlib.collections.PathCollection at 0x12297f6d0&gt; . # T_inv @ T @ v = I @ v = v T = np.array([ [1.3, -2.4], [0.1, 2] ]) trans = T @ xy T_inv = np.linalg.inv(T) un_trans = T_inv @ T @ xy f, axes = plt.subplots(1, 3, figsize=(9, 3)) axes[0].scatter(xx, yy, s=10, c=xx+yy) axes[1].scatter(trans[0].reshape(xx.shape), trans[1].reshape(yy.shape), s=10, c=xx+yy) axes[2].scatter(un_trans[0].reshape(xx.shape), un_trans[1].reshape(yy.shape), s=10, c=xx+yy) . &lt;matplotlib.collections.PathCollection at 0x122a6f2e0&gt; . # transformation by a singular matrix cannot be reset because the points # land on each other in the same space hence non retrievable T = np.array([ [3, 6], [2, 4], ]) trans = T @ xy f, axes = plt.subplots(1, 2, figsize=(6, 3)) axes[0].scatter(xx, yy, s=10, c=xx+yy) axes[1].scatter(trans[0].reshape(xx.shape), trans[1].reshape(yy.shape), s=10, c=xx+yy) # [...] Add axis, x and y witht the same scale . &lt;matplotlib.collections.PathCollection at 0x122b0d9a0&gt; .",
            "url": "https://deepsworld.github.io/blog/linear_algebra/2022/09/14/Linear-Transformation.html",
            "relUrl": "/linear_algebra/2022/09/14/Linear-Transformation.html",
            "date": " • Sep 14, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Probabilities Notes",
            "content": "Random Variables . Random variables are the variables that can take multiple values depending on the result of a random event. e.g. Throwing a dice, tossing a coin, height of a person, size of a rock, etc. . These can be Discrete: fixed number of values it can take, for example, tossing a coin can take only 2 values, heads or tails . or Continuous: any(infine) number of possible values, for example, size of a rock, could be as small as a bug or as large as the mount everest. . Probabilty Distribution . The probability of a random variable describes the probability of each possible result or outcome. In case of a coin toss the probability of both heads and tails is 1/2 so, the probability distribution is 1/2, 1/2. The PD always sums to 1. Higher probaility implies more likely . The probaility distribution of discrete random variable is called Probaility Mass Function | The PD of continuous random variable is called Probabilty Density Function | . import numpy as np import random import matplotlib.pyplot as plt # Probaility Mass Function of &quot;Throwing a Dice&quot; num_throws = 10000 outcomes = np.zeros(num_throws) discrete_outcomes = [1, 2, 3, 4, 5, 6] for i in range(num_throws): outcomes[i] = random.choice(discrete_outcomes) val, counts = np.unique(outcomes, return_counts=True) prob = counts / num_throws plt.bar(val, prob) plt.ylabel(&quot;Probability&quot;) plt.xlabel(&quot;Outcome&quot;) plt.show() plt.close() # verify the output is close enough to theoretical value np.allclose(prob, np.ones(len(prob)) * 1/ 6, atol=0.05) . True . An example of probabilty distributions of 2 discrete random variables . Joint Probability . P(X=x, Y=y) What is the probabilty of throwing a dice and getting 1 and tossing a coin and getting head or tail . Conditional Probability . P(X=x | Y=y) What is the probability of throwing a dice and getting 1 given that tossing a coing resulted in a head . Marginal Probability . P(X=x) What is the probabilty of throwing a dice a getting 1 probabilty distribution of subset of variables . Uniform Distribution . Each value us qually likely to occur. In other words, the probabilty of each value is equal . import seaborn as sns # An example of uniform continuous distribution x = np.random.uniform(0, 0.5, 10000) sns.distplot(x) plt.show() . /usr/local/lib/python3.9/site-packages/seaborn/distributions.py:2619: FutureWarning: `distplot` is a deprecated function and will be removed in a future version. Please adapt your code to use either `displot` (a figure-level function with similar flexibility) or `histplot` (an axes-level function for histograms). warnings.warn(msg, FutureWarning) . Continuous Variables . np.random.seed(123) # draw 1000 values from a normal distribution with mean=0 and std=1 # drawing values implies that the output values will always satisfy the constrains of the normal distribution # these constrains in this case are when we find their mean, it will be 0 and their standard deviation will # be 1 x = np.random.normal(0, 1, 1000) x.shape . (1000,) . x.mean() . -0.03956413608079184 . x.std() # nice ! . 1.0007875375162334 . np.random.seed(123) x = np.random.normal(0, 1, 1000) y = np.random.normal(0, 1, 1000) sns.distplot(x) plt.title(&#39;x&#39;) plt.xlim(-4, 4) plt.show() sns.distplot(y) plt.title(&#39;y&#39;) plt.xlim(-4, 4) plt.show() . /usr/local/lib/python3.9/site-packages/seaborn/distributions.py:2619: FutureWarning: `distplot` is a deprecated function and will be removed in a future version. Please adapt your code to use either `displot` (a figure-level function with similar flexibility) or `histplot` (an axes-level function for histograms). warnings.warn(msg, FutureWarning) . /usr/local/lib/python3.9/site-packages/seaborn/distributions.py:2619: FutureWarning: `distplot` is a deprecated function and will be removed in a future version. Please adapt your code to use either `displot` (a figure-level function with similar flexibility) or `histplot` (an axes-level function for histograms). warnings.warn(msg, FutureWarning) . NOTE: the y-axis here represents the probaility density and the x-axis is the continuous values . Conditional Events can be of 2 types . Dependent Events: Drawing 2 cards from the same deck without replacement. . | Independent Events: One event does not affect the other such as, Throwing a dice and tossing a coin . | .",
            "url": "https://deepsworld.github.io/blog/probability/2022/08/06/Probability-Notes.html",
            "relUrl": "/probability/2022/08/06/Probability-Notes.html",
            "date": " • Aug 6, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Title",
            "content": "",
            "url": "https://deepsworld.github.io/blog/2022/08/06/Norms.html",
            "relUrl": "/2022/08/06/Norms.html",
            "date": " • Aug 6, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Matrices Notes",
            "content": "import numpy as np &#39;&#39;&#39; 3x - y = 7 2x + y = 8 - 5x = 15 x = 3; y = 2 &#39;&#39;&#39; mat = np.array([[3, -1], [2, 1]]) # 2 x 2 rhs = np.array([[7, 8]]) # 1 x 2 out = np.linalg.inv(mat) @ rhs.transpose() # (2 x 2) @ (1 x 2).T out . array([[3.], [2.]]) . I = np.eye(3, 3) I . array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]) . &#39;&#39;&#39; Ainv @ A = I &#39;&#39;&#39; mat = np.random.rand(2, 2) I = np.linalg.inv(mat) @ mat I . array([[1.00000000e+00, 3.32227679e-16], [3.47665962e-18, 1.00000000e+00]]) . NOTE: The output matrix does not look exactly what we expect, this is because of the limitation of floating point precision and for practical purposes e-16 can be considered as zero or very close to zero . singular = np.array([[1, 0], [0, 0]]) singular . array([[1, 0], [0, 0]]) . try: np.linalg.inv(singular) except Exception as e: print(f&#39;Cannot find inverse because: {e}&#39;) . Cannot find inverse because: Singular matrix . det_singular = np.linalg.det(singular) det_singular . 0.0 .",
            "url": "https://deepsworld.github.io/blog/linear_algebra/2022/08/06/Matrices-Notes.html",
            "relUrl": "/linear_algebra/2022/08/06/Matrices-Notes.html",
            "date": " • Aug 6, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "Linear Dependence & Span",
            "content": "import matplotlib.pyplot as plt import numpy as np . def plotVectors(vecs, cols, alpha=1): &quot;&quot;&quot; Plot set of vectors. Parameters - vecs : array-like Coordinates of the vectors to plot. Each vectors is in an array. For instance: [[1, 3], [2, 2]] can be used to plot 2 vectors. cols : array-like Colors of the vectors. For instance: [&#39;red&#39;, &#39;blue&#39;] will display the first vector in red and the second in blue. alpha : float Opacity of vectors Returns: fig : instance of matplotlib.figure.Figure The figure of the vectors &quot;&quot;&quot; plt.figure() plt.axvline(x=0, color=&#39;#A9A9A9&#39;, zorder=0) plt.axhline(y=0, color=&#39;#A9A9A9&#39;, zorder=0) for i in range(len(vecs)): x = np.concatenate([[0,0],vecs[i]]) plt.quiver([x[0]], [x[1]], [x[2]], [x[3]], angles=&#39;xy&#39;, scale_units=&#39;xy&#39;, scale=1, color=cols[i], alpha=alpha) . orange = &#39;#FF9A13&#39; blue = &#39;#1190FF&#39; u = [1, 3] v = [2, 1] plotVectors([u, v], [orange, blue]) plt.xlim(0, 5) plt.ylim(0, 5) . (0.0, 5.0) . a = 2 b = 1 # Start and end coordinates of the vectors u = [0,0,1,3] v = [2,6,2,1] plt.quiver([u[0], a*u[0], b*v[0]], [u[1], a*u[1], b*v[1]], [u[2], a*u[2], b*v[2]], [u[3], a*u[3], b*v[3]], angles=&#39;xy&#39;, scale_units=&#39;xy&#39;, scale=1, color=[orange, orange, blue]) plt.xlim(-1, 8) plt.ylim(-1, 8) # Draw axes plt.axvline(x=0, color=&#39;#A9A9A9&#39;) plt.axhline(y=0, color=&#39;#A9A9A9&#39;) plt.scatter(4,7,marker=&#39;x&#39;,s=50) # Draw the name of the vectors plt.text(-0.5, 2, r&#39;$ vec{u}$&#39;, color=orange, size=18) plt.text(0.5, 4.5, r&#39;$ vec{u}$&#39;, color=orange, size=18) plt.text(2.5, 7, r&#39;$ vec{v}$&#39;, color=blue, size=18) plt.show() plt.close() . Adding 2 vectors: linear combination or weighted sum . a * np.array(u) + b * np.array(v) . array([2, 6, 4, 7]) . Span . All the points we can reach by combininig u and v and changing a and b. This set of points is the span of the vectors u and v .",
            "url": "https://deepsworld.github.io/blog/linear_algebra/2022/08/06/Linear-Dependence-&-Span.html",
            "relUrl": "/linear_algebra/2022/08/06/Linear-Dependence-&-Span.html",
            "date": " • Aug 6, 2022"
        }
        
    
  

  
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page9": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://deepsworld.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}